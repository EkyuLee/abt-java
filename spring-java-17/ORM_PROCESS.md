# ORM (Object-Relation-Mapping)
- 관계형 데이터 베이스의 값을 객체처럼 JAVA에서 사용할 수 있도록 해준다. 

## 핵심 키워드
- DBMS, ORM, JPA, 하이버네이트, 엔티티, 영속성 컨텍스트, 스프링 데이터 JPA

## 장점 과 단점
1. [장점]
    - SQL을 직접 사용하지 않아도 된다.
    - 객체지향적 코드 작성으로 비즈니스 로직에만 집중할 수 있다. 
    - 데이터 베이스 추상화로, 데이터베이스를 변경하더라도 추가 작업이 거의 없다.
    - 매핑하는 정보가 명확하여 ERD에 대한 의존도를 낮출 수 있도 유지보수할 때 유리하다. 

2. [단점]
    - 프로젝트의 복잡성이 커질수록 난이도가 올라감
    - 복잡하고 무거운 쿼리는 안되는 경우가 있음.

## JPA (Java Persistent API)
- *관계형 데이터 베이스를 사용하는 방식을 정의한(기술명세)* 인터페이스 이다. 
- 자바 객체와 데이터베이스를 연결하여 데이터를 관리한다.
- 객체지향 도메인 모델과 데이터베이스의 다리 역할을 한다.
- ORM 프레임워크를 추가로 선택해야 하는데, 대표적으로 Hibernate 를 많이 사용한다.
- Application <-> 'JPA' - 'Hibernate' - 'JDBC' <-> DATABASE
- 표준스펙 = Spring data JPA, 몽고디비 = Spring data MongoDB 

## Hibernate
- *JPA 인터페이스를 구현한 구현체*이자 자바용 ORM 프레임 워크 이다. 
- 자바를 객체를 통해 종류 상관없이 데이터 베이스를 자유자재로 사용할 수 있도록 하는것에 있음.
- JPA의 인터페이스를 구현한다
- 내부적으로는 JDBC API를 사용한다.

## SpringDATA JPA
- JPA를 쓰기 편하게 만들어 둔 모듈 (JpaRepository를 상속받아 사용하는 repository)

## Entity Manager
1. [Entity 란?]
   - 자바 객체이다, 하지만 데이터베이스의 테이블과 직접 연결된다는 특징이 있다. 즉 쿼리를 실행하는 격이다. 

2. [Entity Manager 란?]
   - 엔티티를 관리하여 어플리케이션 사이에서 객체를 생성, 수정, 삭제 하는 등의 역할을 한다. 
   - 엔티티 매니저를 만드는 곳은 엔티티 매니저 팩토리 이다.
   - 순서 : 입력 요청 -> 엔티티 메니저 팩토리에서 엔티티 메니저 생성 -> 엔티티 메니저에서 필요한 시점에 따라 DB에 입력 진행
   - 스프링 부트에서는 Entity manager Factory를 하나만 만들어서 관리한다. 아래 예제 참조
   ```java
   // example 
   @PersistenceContext
   EntityManager em; // 프록시 엔티티 메니저, 필요할 때 진짜 엔티티 매니저 호출
   ```
   - 쉽게 말해 SPRING DATA JPA에서 직접 관리하므로, 직접 생성이나 관리할 필요 없음.

3. [영속성 컨텍스트란 ?] - persistence context
   - 엔티티 메니저가 엔티티를 저장하는 가상의 공간
   - JPA의 중요한 특징중 하나로, 엔티티를 관리하는 가상의 공간이다.
   - 이것으로 인해 데이터베이스에서 데이터를 효과적으로 가져올 수 있고, 엔티티를 편하게 사용할 수 있다.

4. [영속성 컨텍스트의 기본적 특징 4가지] - 4가지 특징 모두 DB접근을 최소화 하여 성능 향상이 가능함.
   > 4-1. 1차 캐시
   > > 영속성 컨텍스트가 가지고 있으며, 이떄 키는 @id annotation이 달린 기본키 역할의 식별자 이다.
   > > 캐시된 데이터를 조회할때에는 DB를 거치지 않아도 되기 때문에 빠르다. 
   
   > 4-2. 쓰기 지연
   > > 트랜잭션을 커밋하기 전까지 데이터 베이스로 실제로 질의문을 보내지 않고 쿼리를 모았다가 커밋을 하면 쿼리가 한번에 실행되는것을 나타냄.
   > > 이를 통해 적당한 묶음으로 쿼리를 요청할 수 있기 때문에 데이터베이스 시스템의 부담을 줄일 수 있다.

   > 4-3. 변경 감지
   > > 트랜잭션 커밋시 1차 캐시에 저장되어 있는 엔티티의 값을 현재 엔티티의 값과 비교하여 변경이 된 값이 있다면 변경사항 감지 후 변경된 값을 데이터베이스에 자동으로 반영함. 
   > > 쓰기 지연과 마찬가지로 적당한 묶음으로 쿼리를 요청할 수 있고, 데이터 베이스 시스템의 부담을 줄일 수 있다. 
   
   > 4-4. 지연 로딩 
   > > 쿼리로 요청한 데이터를 어플리케이션으로 바로 로딩하는것이 아닌, 필요할때 쿼리를 날려 데이터를 조회 하는것이다. 
   > > 반대로 조회할때 쿼리를 보내 연관된 모든 데이터를 가져오는 즉시 로딩도 있음.

5. [엔티티의 상태] - 분리, 관리(persistent context 가 관리), 비영속, 삭제
```java
// example
public class EntityManagerTest{
    @Autowired
    EntityManager me;
    
    public void example(){
        Member member = new Member(1L, "abc"); //(비영속 상태) 엔티티 매니저가 엔티티를 관리하지 않는 상태
        em.persist(member); //(관리 상태) 엔티티가 관리 되는 상태
        em.detach(member); //(분리 상태) 엔티티 객체가 분리된 상태
        em.remove(member); //(삭제 상태) 엔티티 객체가 삭제된 상태
    }
}
     /*
     * 요약하자면, 엔티티 상태를 관리를 하면, 트랜잭션 관리를 통해서 디비 접근을 최소화 하는데 해당 entity를 사용하지만, 
     * detach를 하면 영속성 관리를 하지 않고 분리할 수 있다,
     * 그리고 remove를 사용해서 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제할 수 있다.
     * 손쉽게 CRUD를 사용하기 위해서 repository를 지원한다 . 
     */
```

6. [ENTITY 자동키 생성 설정 방식]
    - AUTO : 선택한 데이터베이스 방언(dialect)에 따라 방식을 자동으로 선택 (기본값)
    - IDENTITY : 기본키 생성을 데이터 베이스에 위임함 (Auto_increment)
    - SEQUENCE : DB 시퀀스를 사용해서 기본키를 할당 (오라클 주로 사용)
    - TABLE : 키 생성 테이블 사용

7. [Column annotation 속성]
    - name : 필드와 매핑할 컬럼이름, 미작성시 필드 이름으로 지정을 해줌
    - nullable : null 허용 여부 (false = 미허용)
    - unique : 컬럼의 유일한 값(unique), 미설정시 non unique
    - ColumnDefinition : 컬럼 정보 설정, default 값을 줄 수 있음